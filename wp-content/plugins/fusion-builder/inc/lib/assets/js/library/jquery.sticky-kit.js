/* global fusion, fusionGetStickyOffset */
// Generated by CoffeeScript 1.9.2

/**
@license Sticky-kit v1.1.2 | WTFPL | Leaf Corcoran 2015 | http://leafo.net
 */

( function() {
	var $, win;

	$ = this.jQuery || window.jQuery;

	win = $( window );

	$.fn.stick_in_parent = function( opts ) {
		var doc, elm, enable_bottoming, fn, i, inner_scrolling, len, manual_spacer, offset_top, parent_selector, recalc_every, sticky_class, transition_offset, should_observer, scroll_transition_offset, clone, doingReset, stuck, reset, sidebar_reset;
		if ( null == opts ) {
			opts = {};
		}
		sticky_class             = opts.sticky_class;
		inner_scrolling          = opts.inner_scrolling;
		recalc_every             = opts.recalc_every;
		parent_selector          = opts.parent;
		offset_top               = opts.offset_top;
		manual_spacer            = opts.spacer;
		enable_bottoming         = opts.bottoming;
		transition_offset        = 'undefined' === typeof opts.transition_offset ? false : parseFloat( opts.transition_offset );
		should_observer          = 'undefined' === typeof opts.observer ? false : opts.observer;
		scroll_transition_offset = 'undefined' === typeof opts.scroll_transition ? false :  parseFloat( opts.scroll_transition );
		clone                    = 'undefined' === typeof opts.clone ? false : opts.clone;
		doingReset               = false;
		adminBarHeight           = fusion.getAdminbarHeight();

		if ( null == offset_top ) {
			offset_top = 0;
		}

		// Helper to get offset.
		if ( 'fusion-container-stuck' === sticky_class && 'object' === typeof fusion && 'function' === typeof fusion.getHeight ) {
			offset_top = fusion.getHeight( offset_top ) + adminBarHeight;
		}

		if ( null == parent_selector ) {
			parent_selector = void 0;
		}
		if ( null == inner_scrolling ) {
			inner_scrolling = true;
		}
		if ( null == sticky_class ) {
			sticky_class = 'is_stuck';
		}
		doc = $( document );
		if ( null == enable_bottoming ) {
			enable_bottoming = true;
		}

		fn = function( elm, padding_bottom, parent_top, parent_height, top, height, el_float, detached ) {
			var bottomed, detach, fixed, last_pos, last_scroll_height, offset, parent, recalc, recalc_and_tick, recalc_counter, spacer, tick, observer, observerOptions, resize_ob;
			if ( elm.data( 'sticky_kit' ) ) {
				return;
			}
			elm.attr( 'data-sticky_kit', true );
			last_scroll_height = doc.height();
			parent = elm.parent();
			if ( null != parent_selector ) {
				parent = parent.closest( parent_selector );
			}
			if ( !parent.length ) {
				throw 'failed to find stick parent';
			}
			fixed = false;
			bottomed = false;

			if ( null != manual_spacer ) {
				spacer = manual_spacer && elm.closest( manual_spacer );
			}  else if ( clone ) {
				spacer = elm.clone( false );
				spacer.addClass( 'fusion-sticky-spacer' ).removeClass( 'fusion-sticky-transition' );
			} else {
				spacer = jQuery( '<div class="fusion-sticky-spacer" />' );
			}
			if ( spacer ) {
				spacer.css( 'position', elm.css( 'position' ) );
			}


			overlap = function( entries, observer ) {
				// Check if overlapping and if so remove class if set.
				if ( 'object' === typeof entries && 'object' === typeof entries[ 0 ] ) {
					if ( entries[ 0 ].isIntersecting ) {
						elm.removeClass( 'fusion-sticky-transition' );
					} else {
						elm.addClass( 'fusion-sticky-transition' );
					}
				}
			};

			if ( should_observer ) {
				observerOptions = {
					rootMargin: '0px',
					threshold: 1.0
				};

				observer = new IntersectionObserver( overlap, observerOptions );
			}

			if ( enable_bottoming && 'function' === typeof ResizeObserver ) {
				resize_ob = new ResizeObserver( function( entries ) {
					let rect      = entries[0].contentRect;
					parent_height = rect.height;
					reset();
				} );
				resize_ob.observe( parent[0] );
			}

			recalc = function() {
				var border_top, padding_top, restore, spacerCSS, transform_height, transform_css_property;
				if ( detached ) {
					return;
				}

				last_scroll_height = doc.height();
				border_top         = parseInt( parent.css( 'border-top-width' ), 10 );
				padding_top        = parseInt( parent.css( 'padding-top' ), 10 );
				padding_bottom     = parseInt( parent.css( 'padding-bottom' ), 10 );
				parent_top         = parent.offset().top + border_top + padding_top;
				parent_height      = parent.height();

				if ( fixed ) {
					fixed    = false;
					bottomed = false;
					if ( null == manual_spacer ) {
						if ( elm.next( '.fusion-sticky-spacer' ).length ) {
							spacer = elm.next( '.fusion-sticky-spacer' );
						} else {
							elm.insertAfter( spacer );
						}
					}

					elm.css( {
						position: '',
						top: '',
						width: '',
						bottom: ''
					} ).removeClass( sticky_class );
					restore = true;
				}

				transform_height = 0;
				transform_css_property = elm.css( 'transform' );
				if ( transform_css_property.includes( 'matrix(' ) && elm.hasClass( 'fusion-sticky-scroll-transition' ) ) {
					transform_css_property = transform_css_property.slice(7, transform_css_property.length - 1).split(', ');
					if ( 'undefined' !== typeof transform_css_property[5] ) {
						transform_height = - parseFloat( transform_css_property[5] );
					}
				}

				top      = transform_height + elm.offset().top - ( parseInt( elm.css( 'margin-top' ), 10 ) || 0 ) - offset_top;
				height   = elm.outerHeight( true );

				el_float = elm.css( 'float' );
				if ( spacer ) {

					spacerCSS = {
						width: elm.outerWidth( true ),
						display: elm.css( 'display' ),
						'vertical-align': elm.css( 'vertical-align' ),
						'float': el_float
					};
					// Only set height if we are not cloning.
					if ( ! clone ) {
						spacerCSS.height = height;
					}

					spacer.css( spacerCSS );
				}
				if ( restore ) {
					return tick();
				}
			};
			recalc();
			if ( height === parent_height ) {
				return;
			}
			last_pos = void 0;
			offset = offset_top;
			recalc_counter = recalc_every;

			tick = function() {
				var css, delta, recalced, scroll, will_bottom, win_height;
				if ( detached ) {
					return;
				}
				recalced = false;
				if ( null != recalc_counter ) {
					recalc_counter -= 1;
					if ( 0 >= recalc_counter ) {
						recalc_counter = recalc_every;
						recalc();
						recalced = true;
					}
				}
				if ( null != recalc_counter && !recalced && doc.height() !== last_scroll_height ) {
					recalc();
					recalced = true;
				}
				scroll = win.scrollTop();
				if ( null != last_pos ) {
					delta = scroll - last_pos;
				}

				last_pos = scroll;
				if ( fixed ) {
					if ( enable_bottoming ) {
						will_bottom = scroll + height + offset > parent_height + parent_top;
						if ( bottomed && !will_bottom ) {
							bottomed = false;
							elm.css( {
								position: 'fixed',
								bottom: '',
								top: offset
							} ).trigger( 'sticky_kit:unbottom' );
						}
					}
					if ( scroll < top ) {
						fixed = false;
						offset = offset_top;
						if ( null == manual_spacer ) {
							if ( 'left' === el_float || 'right' === el_float ) {
								elm.insertAfter( spacer );
							}
							if ( spacer ) {
								spacer.detach();
							}
						}
						css = {
							position: '',
							width: '',
							top: ''
						};
						elm.css( css ).removeClass( sticky_class ).trigger( 'sticky_kit:unstick' );
						if ( 'fusion-container-stuck' === sticky_class ) {
							win.trigger( 'fusion-sticky-change' );
						}
					}
					if ( inner_scrolling ) {
						win_height = win.height();
						if ( height + offset_top > win_height ) {
							if ( !bottomed ) {
								offset -= delta;
								offset = Math.max( win_height - height, offset );
								offset = Math.min( offset_top, offset );
								if ( fixed ) {
									elm.css( {
										top: offset + 'px'
									} );
								}
							}
						}
					}
				} else if ( scroll > top || scroll === top ) { // ThemeFusion Edit for #6101
					fixed = true;
					css = {
						position: 'fixed',
						top: offset
					};
					css.width = 'border-box' === elm.css( 'box-sizing' ) ? elm.outerWidth() + 'px' : elm.width() + 'px';
					elm.css( css ).addClass( sticky_class );
					if ( null == manual_spacer ) {
						elm.after( spacer );
						if ( 'left' === el_float || 'right' === el_float ) {
							spacer.append( elm );
						}
					}
					elm.trigger( 'sticky_kit:stick' );
					if ( 'fusion-container-stuck' === sticky_class ) {
						win.trigger( 'fusion-sticky-change' );
					}
				}

				// Transition offset handking if not observer mode.
				if ( false !== transition_offset && ! should_observer ) {
					if ( ! elm.is( '.fusion-sticky-transition' ) && scroll - top > transition_offset ) {
						elm.addClass( 'fusion-sticky-transition' );
						if ( 'fusion-container-stuck' === sticky_class ) {
							win.trigger( 'fusion-sticky-transition-change' );
						}
					} else if ( elm.is( '.fusion-sticky-transition' ) && scroll - top <= transition_offset ) {
						elm.removeClass( 'fusion-sticky-transition' );
						if ( 'fusion-container-stuck' === sticky_class ) {
							win.trigger( 'fusion-sticky-transition-change' );
						}
					}
				}

				// Scroll transition offset handking if not observer mode.
				if ( false !== scroll_transition_offset && 0 !== scroll_transition_offset ) {

					// Whether scroll direction is up or down.
					if ( 0 > delta && ! window.scrollDisabled ) {
						if ( ! elm.hasClass( 'fusion-scrolling-up' ) ) {
							elm.addClass( 'fusion-scrolling-up' ).removeClass( 'fusion-scrolling-down' );
							win.trigger( 'fusion-sticky-scroll-change' );
						}
					} else if ( ! elm.hasClass( 'fusion-scrolling-down' ) ) {
						elm.addClass( 'fusion-scrolling-down' ).removeClass( 'fusion-scrolling-up' );
						win.trigger( 'fusion-sticky-scroll-change' );
					}

					// Active class for when to kick in.
					if ( ! elm.is( '.fusion-sticky-scroll-transition' ) && scroll - top > scroll_transition_offset ) {
						elm.addClass( 'fusion-sticky-scroll-transition' );

						// Passed activation point and sccrolling down, means we are hiding.
						if ( 'fusion-container-stuck' === sticky_class ) {
							win.trigger( 'fusion-sticky-scroll-change' );
						}
					} else if ( elm.is( '.fusion-sticky-scroll-transition' ) && scroll - top <= scroll_transition_offset ) {
						elm.removeClass( 'fusion-sticky-scroll-transition' );

						// Currently hidden, now above cut off point, we are revealing.
						if ( 'fusion-container-stuck' === sticky_class ) {
							win.trigger( 'fusion-sticky-scroll-change' );
						}
					}
				}


				if ( fixed && enable_bottoming ) {
					if ( null == will_bottom ) {
						will_bottom = scroll + height + offset > parent_height + parent_top;
					}
					if ( !bottomed && will_bottom ) {
						bottomed = true;
						if ( 'static' === parent.css( 'position' ) ) {
							parent.css( {
								position: 'relative'
							} );
						}
						return elm.css( {
							position: 'absolute',
							bottom: padding_bottom,
							top: 'auto'
						} ).trigger( 'sticky_kit:bottom' );
					}
				}
			};
			recalc_and_tick = function() {
				recalc();
				return tick();
			};

			reset = function( event ) {
				var customOffset;

				// Recalculate the offset if required.
				if ( 'object' === typeof fusion && 'function' === typeof fusion.getHeight ) {
					offset_top = 'undefined' === typeof opts.offset_top ? 0 : opts.offset_top;

					if ( 'fusion-container-stuck' === sticky_class ) {
						offset_top = fusion.getHeight( offset_top ) + adminBarHeight;
					} else if ( 'fusion-sidebar-stuck' === sticky_class ) {
						if ( jQuery( '.fusion-tb-header' ).length && 'function' === typeof fusionGetStickyOffset ) {
							customOffset = fusionGetStickyOffset();
							if ( customOffset ) {
								offset_top = customOffset + adminBarHeight + 50;
							}
						}
					}

					offset = offset_top;
				}

				// Not debounced for smoothness.
				recalc_and_tick();

				// Trailing debounced call.
				if ( 'undefined' !== typeof event && 'string' === typeof event.type && 'resize' === event.type && 'function' === typeof _debounced_final_reset ) {
					_debounced_final_reset();
				}
			};

			if ( 'object' === typeof fusion && 'function' === typeof fusion.debounce ) {
				var	_debounced_final_reset  = fusion.debounce( reset, 350 );
			}

			sidebar_reset = function( event ) {
				if ( doingReset ) {
					return;
				}

				doingReset = true;

				// Consider checking for non fixed only here.
				reset( event );

				_debounced_final_reset();

				// Reset var.
				setTimeout( function() {
					doingReset = false;
				}, 100 );
			};

			stuck = function() {
				if ( should_observer ) {
					observer.observe( elm.next()[ 0 ] );
				}
			};
			detach = function() {
				detached = true;
				win.off( 'touchmove', tick );
				win.off( 'scroll', tick );
				win.off( 'resize', reset );
				$( document.body ).off( 'sticky_kit:recalc', recalc_and_tick );
				if ( 'fusion-container-stuck' === sticky_class ) {
					win.trigger( 'fusion-sticky-change' );
				}
				elm.off( 'sticky_kit:detach', detach );
				elm.removeData( 'sticky_kit' );
				elm.removeAttr( 'data-sticky_kit' );
				elm.css( {
					position: '',
					bottom: '',
					top: '',
					width: ''
				} );
				elm.removeClass( 'fusion-sticky-transition' );
				parent.position( 'position', '' );
				if ( fixed ) {
					if ( null == manual_spacer ) {
						if ( 'left' === el_float || 'right' === el_float ) {
							elm.insertAfter( spacer );
						}
						spacer.remove();
					}
					return elm.removeClass( sticky_class );
				}

				if ( elm.next( '.fusion-sticky-spacer' ).length ) {
					elm.next( '.fusion-sticky-spacer' ).remove();
				}
			};

			if ( spacer ) {
				spacer.detach();
			}
			// Sidebar with custom header, we need to listed for those containers changing.
			if ( 'fusion-sidebar-stuck' === sticky_class && jQuery( '.fusion-tb-header' ).length ) {
				win.on( 'fusion-sticky-change fusion-sticky-scroll-change fusion-sticky-transition-change', sidebar_reset );
			}

			win.on( 'touchmove', tick );
			win.on( 'scroll', tick );
			win.on( 'resize', reset );
			$( document.body ).on( 'sticky_kit:recalc', recalc_and_tick );
			elm.on( 'sticky_kit:detach', detach );
			elm.on( 'sticky_kit:stick', stuck );

			return setTimeout( tick, 0 );
		};
		for ( i = 0, len = this.length; i < len; i++ ) {
			elm = this[ i ];
			fn( $( elm ) );
		}
		return this;
	};

} ).call( this );
